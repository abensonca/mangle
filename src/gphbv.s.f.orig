c-----------------------------------------------------------------------
c © A J S Hamilton 2001
c-----------------------------------------------------------------------
c * WARNING:
c * This routine does not yet deal with multiple intersections.
c-----------------------------------------------------------------------
      subroutine gphbv(bound,vert,rp,cm,np,npb,npc,i,tol,phi,iord)
      integer np,npb,npc,i,iord(2*np)
      real*8 bound(2),vert(2),rp(3,np),cm(np),tol,phi(2,np)
c
c        parameters
      include 'pi.par'
      real*8 TWOPI
      parameter (TWOPI=2.d0*PI)
c        externals
      integer gzeroar
c        data variables
      real*8 big,areatol
      real*8 dphmin
c        local (automatic) variables
      integer j,jp,k,km,kp,l,ni,samebd
      logical warn
      real*8 bi,bj,cmi,cmij,cmik,cmj,cmk,cpsi,cti,ctk,
     *  d,dbound(2),dc,dph,dvert(2),p,phm,php,psi,
     *  si,sk,spsi,xi(3),xj,yi(3),yj
c *
c * Correction to boundary and vertex terms per subroutine gspher
c * arising from disjoint regions W12 and W13 which abut along circle i
c * defined by 1 - r.rp(i) = cm(i).
c * W12 (W13) is the intersection of W2 (W3) with global region W1.
c * Regions are bounded by
c *    1 - r.rp(j) < cm(j)  (if cm(j).ge.0)
c *    1 - r.rp(j) > -cm(j)  (if cm(j).lt.0)
c * for j=1,np where rp(j) are unit directions.
c * The boundary of W2 is in j =     1 to npb
c *                 W3           npb+1 to npc
c *                 W1           npc+1 to np.
c * If circle i belongs to W2 (i.e. i=1 to npb) then
c * W2 (W3) is north (south) of circle i if cm(i).ge.0,
c *            south (north) of circle i if cm(i).lt.0.
c * Conversely, if circle i belongs to W3 (i.e. i=npb+1 to npc) then
c * W3 (W2) is north (south) of circle i if cm(i).ge.0,
c *            south (north) of circle i if cm(i).lt.0.
c * The abutting boundary i' of W3 (W2) which coincides with
c * boundary i of W2 (W3) should be suppressed by setting cm(i')=2.
c *
c * Boundary and vertex terms are evaluated for -<W12 W13>.
c *
c * To get bound & vert for correlation <(W1-W12-W13)^2>
c * of region W1 less its intersection with disjoint regions W2 and W3,
c * follow instructions in gspher, i.e. basically
c *    call gspher(area,bound,vert,parameters of W1,ibv=0,...)
c *    call gspher(darea,dbound,dvert,parameters of W2 & W1,ibv=2,...)
c *    area=area-darea, etc.
c *    call gspher(darea,dbound,dvert,parameters of W3 & W1,ibv=2,...)
c *    area=area-darea, etc.
c * and then, if W2 and W3 abut,
c *    call gphbv(dbound,dvert,parameters of W2 W3 & W1,...)
c *    bound=bound-2*dbound
c *    vert=vert-2*dvert
c *
c * To get bound & vert for cross-correlation <W12(W1-W13)>
c * between W12
c * and region W1 less its intersection with W3 outside W2,
c * follow instructions in gspher, i.e.
c *    call gspher(area,bound,vert,parameters of W2 & W1,ibv=1,...)
c * and then, if W2 and W3 abut,
c *    call gphbv(dbound,dvert,parameters of W2 W3 & W1,...)
c *    bound=bound+dbound
c *    vert=vert+dvert
c *
c * To get bound & vert for cross-correlation <(W12-W13)(W1-W13)>
c * between W12 less its intersection with W3 inside W2,
c * and region W1 less its intersection with W3,
c * follow instructions in gspher, i.e.
c *    call gspher(area,bound,vert,parameters of W2 & W1,ibv=1,...)
c *    call gspher(darea,dbound,dvert,parameters of W3 & W12,ibv=2,...)
c *    area=area-darea, etc.
c * and then, if W2' and W3 abut, where W2' denotes complement of W2,
c *    call gphbv(dbound,dvert,parameters of W2' W3 & W1,...)
c *    bound=bound-dbound
c *    vert=vert-dvert
c * Note that usually all W2' constraints should be null.
c * If however W2' abuts W3 along two distinct boundaries, then W2'
c * should be split into two regions W2'a and W2'b which each have a
c * single abutment with W3, and two calls to gphbv should be made
c *    call gphbv(dbound,dvert,parameters of W2'a W3 & W1,...)
c *    bound=bound-dbound
c *    vert=vert-dvert
c *    call gphbv(dbound,dvert,parameters of W2'b W3 & W1,...)
c *    bound=bound-dbound, etc.
c *
c * In general, to get bound & vert for cross-correlation
c * <(W12-W13-...)(W1-W13-W14-...)>
c * between region W12 less its intersection W13 with a
c * bunch of disjoint W3 lying inside W2,
c * and W1 less its intersections W13 and W14 with that bunch of W3 and
c * another bunch of disjoint W4 lying outside W2,
c *    call gspher(area,bound,vert,parameters of W2 & W1,ibv=1,...)
c * then chop out all the W13s by calls
c *    call gspher(darea,dbound,dvert,parameters of W3 & W12,ibv=2,...)
c *    area=area-darea, etc.
c * then for each W3 (inside W2) abutting the edge of W2
c *    call gphbv(dbound,dvert,parameters of W2' W3 & W1,...)
c *    bound=bound-dbound, etc.
c * for each W4 (outside W2) abutting W2
c *    call gphbv(dbound,dvert,parameters of W2 W4 & W1,...)
c *    bound=bound+dbound, etc.
c * for each pair W3a & W3b (inside W2) which abut each other
c *    call gphbv(dbound,dvert,parameters of W3a W3b & W1,...)
c *    bound=bound-2*dbound, etc.
c * for each pair W3 (inside W2) & W4 (outside W2) abutting each other
c *    call gphbv(dbound,dvert,parameters of W3 W4 & W1,...)
c *    bound=bound-dbound, etc.
c *
c * Note that regions which abut at only a point are considered to abut.
c * In the case of a point abut (or other multiple abutment),
c * only one call (not more) to gphbv should be made.
c * As remarked below, the additional abutting boundaries must be
c * identical between W2 and W3.
c *
c * Caution:
c * As alluded to in the comments to subroutine gspher,
c * there is a discontinuity in the vertex terms whenever there
c * are multiple (.ge. 3) intersections of boundaries.
c * The only kind of multiple intersection which this subroutine deals
c * with is the case where W2 and W3 have an identical boundary
c * (i.e. rp and |cm| are *exactly* the same)
c * besides their abutting boundary.
c *
c  Input: rp(3,j),j=1,np
c         cm(j),j=1,np
c         np, npb, npc: W2     1 to npb
c                       W3 npb+1 to npc
c                       W1 npc+1 to np.
c         i = abutting boundary of W2 (or W3);
c             the abutting boundary i' of W3 (or W2) which coincides
c             with boundary i of W2 (or W3) should be suppressed
c             by setting cm(i')=2.
c Output: bound(2)
c         vert(2)
c Work arrays: phi and iord should be dimensioned at least 2*np
c
c        set azimuthal angle of non-intersection to big
      data big /1.d6/
c        ok if area tests not too far outside [0,max]
      data areatol /1.d-10/
c        warn about multiple intersection when dph < dphmin
      data dphmin /1.d-8/
c
c        abutting boundary must belong to W2 or W3
      if (i.gt.npc) then
        print *,'*** from gphbv: i =',i,' should be .le.',npc
        goto 410
      endif
c        zero stuff
      bound(1)=0.d0
      bound(2)=0.d0
      vert(1)=0.d0
      vert(2)=0.d0
      warn=.false.
c        check for zero angle because one circle is null
      if (gzeroar(cm,np).eq.0) goto 410
c        cm(i).ge.2 means include whole sphere, which is no constraint
      if (cm(i).ge.2.d0) goto 410
c--------identify boundary segments around circle i
      cmi=abs(cm(i))
      si=sqrt(cmi*(2.d0-cmi))
c........construct cartesian axes with z-axis along rp(i)
      call gaxisi(rp(1,i),xi,yi)
c........angles phi about z-axis rp(i) of intersection of i & j circles
CCCC  call gphij(rp,cm,np,i,rp(1,i),scmi,cmi,xi,yi,big,tol,ni,phi)

c........angles phi about z-axis rp(i) of intersection with j circle
c        initialise phi to big, meaning no intersection
      do j=1,np
        phi(1,j)=big
        phi(2,j)=big
      enddo
c        set count of number of intersections to zero
      ni=0
c        find intersection of i circle with each j circle in turn
      do 150 j=1,np
c        skip self
        if (j.eq.i) goto 150
c        cm(j).ge.2 means include whole sphere, so no intersection
        if (cm(j).ge.2.d0) goto 150
c        cmij = 2 sin^2[th(ij)/2] = 1-cos th(ij)
        cmij=((rp(1,i)-rp(1,j))**2+(rp(2,i)-rp(2,j))**2
     *    +(rp(3,i)-rp(3,j))**2)/2.d0
c        cmj = 1-cos th(j)
c        bj = cj-ci*cij
c        d = 1-ci^2-cj^2-cij^2+2*ci*cj*cij
c        dph = atan(sqrt(d)/bj) is angle from rp(j) to intersection
        cmj=abs(cm(j))
        bj=(cmi-cmj)+cmij*(1.d0-cmi)
        d=-(cmi-cmj)**2+cmij*(2.d0*((cmi+cmj)-cmi*cmj)-cmij)
        dc=cmi**2+cmj**2
c        positive d means i and j circles intersect
c        if d is zero within numerical round off, treat it as zero
        if (d+dc.gt.dc) then
          d=sqrt(d)
c        ph = atan(yj/xj) is angle from xi to rp(j)
          xj=xi(1)*rp(1,j)+xi(2)*rp(2,j)+xi(3)*rp(3,j)
          yj=yi(1)*rp(1,j)+yi(2)*rp(2,j)+yi(3)*rp(3,j)
c        order intersection angles so segment from first to second angle
c        is inside j circle
c Notice order of evaluation of RHS of phi(1,j) and phi(2,j) is same;
c this ensures that gcc evaluates identically for identical arguments.
          if (cm(j).ge.0.d0) then
c        phi(1,j)=ph-dph , phi(2,j)=ph+dph
            phi(1,j)=atan2(yj*bj-xj*d,xj*bj+yj*d)
            phi(2,j)=atan2(yj*bj+xj*d,xj*bj-yj*d)
          elseif (cm(j).lt.0.d0) then
c        phi(1,j)=ph+dph , phi(2,j)=ph-dph
            phi(2,j)=atan2(yj*bj-xj*d,xj*bj+yj*d)
            phi(1,j)=atan2(yj*bj+xj*d,xj*bj-yj*d)
          endif
c        increment count of number of intersections
          ni=ni+2
c        zero d means j circle just touches i circle;
c        negative d means j circle doesn't intersect i circle
        else
c        bi = ci-cj*cij
          bi=(cmj-cmi)+cmij*(1.d0-cmj)
c        bi=0 means i and j circles coincide, implying also bj=0 and d=0
c        but test both bi and bj to guard against numerics
          if (bi.eq.0.d0.or.bj.eq.0.d0) then
c        null intersection of areas:
c        abutting boundary coincides with W1 boundary
            if (j.gt.npc) goto 410
c        abutting W2 (W3) boundary coincides with W2 (W3) boundary
            if ((i.le.npb.and.j.le.npb)
     *        .or.(i.gt.npb.and.j.gt.npb)) then
c        rp(i) and rp(j) point in same direction
              if (cmij.lt.1.d0) then
c        cm(i) and cm(j) have opposite sign
                if ((cm(i).ge.0.d0.and.cm(j).lt.0.d0)
     *            .or.(cm(i).lt.0.d0.and.cm(j).ge.0.d0)) goto 410
c        rp(i) and rp(j) point in opposite directions
              elseif (cmij.gt.1.d0) then
c        cm(i) and cm(j) have same sign
                if ((cm(i).ge.0.d0.and.cm(j).ge.0.d0)
     *            .or.(cm(i).lt.0.d0.and.cm(j).lt.0.d0)) goto 410
              endif
c        abutting W2 (W3) boundary coincides with W3 (W2) boundary
            elseif ((i.le.npb.and.j.gt.npb)
     *        .or.(i.gt.npb.and.j.le.npb)) then
c        rp(i) and rp(j) point in same direction
              if (cmij.lt.1.d0) then
c        cm(i) and cm(j) have same sign
                if ((cm(i).ge.0.d0.and.cm(j).ge.0.d0)
     *            .or.(cm(i).lt.0.d0.and.cm(j).lt.0.d0)) goto 410
c        rp(i) and rp(j) point in opposite directions
              elseif (cmij.gt.1.d0) then
c        cm(i) and cm(j) have opposite sign
                if ((cm(i).ge.0.d0.and.cm(j).lt.0.d0)
     *            .or.(cm(i).lt.0.d0.and.cm(j).ge.0.d0)) goto 410
              endif
            endif
c        i circle is outside j circle, so angle is zero
          elseif ((cm(j).ge.0.d0.and.bj.gt.0.d0)
     *      .or.(cm(j).lt.0.d0.and.bj.lt.0.d0)) then
            goto 410
          endif
        endif
  150 continue

c........i circle has no intersections
      if (ni.eq.0) then
        dph=TWOPI
        dbound(1)=si*dph
        dbound(2)=(1.d0/si-2.d0*si)*dph
        bound(1)=bound(1)+dbound(1)
        bound(2)=bound(2)+dbound(2)
C       print *,'full circle'
C       print *,'dbound, bound =',dbound(1),dbound(2),
C    *    bound(1),bound(2)
c........i circle has intersections
      elseif (ni.gt.0) then
c        find ordering of intersection angles around i circle
        call findbot(phi,2*np,iord,ni)
c........contribution from each segment of i circle
        do 260 j=1,ni
c        normal segment
          if (j.ne.ni) then
            jp=j+1
c        last angle links to first angle
          elseif (j.eq.ni) then
            jp=1
          endif
          km=(iord(j)+1)/2
          kp=(iord(jp)+1)/2
c        lower and upper angles of segment
          phm=phi(1+mod(iord(j)+1,2),km)
          php=phi(1+mod(iord(jp)+1,2),kp)
          samebd=0
c        check whether multiple intersection is from identical boundary
          if (phm.eq.php) then
c        check one boundary is from W2, other from W3
            if ((km.le.npb.and.kp.gt.npb.and.kp.le.npc)
     *        .or.(kp.le.npb.and.km.gt.npb.and.km.le.npc)) then
c        check boundaries are identical
              if (rp(1,km).eq.rp(1,kp).and.rp(2,km).eq.rp(2,kp)
     *          .and.rp(3,km).eq.rp(3,kp)
     *          .and.abs(cm(km)).eq.abs(cm(kp))) then
c        W2 & W3 on same side of boundary
                if ((cm(km).ge.0.d0.and.cm(kp).ge.0.d0)
     *            .or.(cm(km).lt.0.d0.and.cm(kp).lt.0.d0)) then
                  samebd=1
c        W2 & W3 on opposite sides of boundary
                elseif ((cm(km).ge.0.d0.and.cm(kp).lt.0.d0)
     *            .or.(cm(km).lt.0.d0.and.cm(kp).ge.0.d0)) then
                  samebd=-1
                endif
              endif
            endif
          elseif (phm.ne.php) then
c        lower angle must be lower limit of some segment
            if (mod(iord(j),2).ne.1) goto 260
c        upper angle must be upper limit of some segment
            if (mod(iord(jp),2).ne.0) goto 260
          endif
c        check segment satisfies all conditions
          if (j.ne.ni) then
            do 220 k=1,np
              if (phi(2,k).eq.big) goto 220
              if (phi(2,k).ge.phi(1,k)) then
                if (phm.lt.phi(1,k).or.php.gt.phi(2,k)) goto 260
              elseif (phi(2,k).lt.phi(1,k)) then
                if (phm.lt.phi(1,k).and.php.gt.phi(2,k)) goto 260
              endif
  220       continue
            dph=php-phm
          elseif (j.eq.ni) then
            do 230 k=1,np
              if (phi(2,k).eq.big) goto 230
              if (phi(2,k).ge.phi(1,k)) goto 260
  230       continue
            dph=php-phm+TWOPI
          endif
c        warn about near multiple intersection
          if (abs(dph).lt.dphmin.and.samebd.eq.0) then
            print *,
     *        '*** warning from gphbv: near multiple intersection at',
     *        i,' (',npb,npc,np,'): segment',km,kp
            write (*,'(" phi-, phi+, dph = ",3g25.17)') phm,php,dph
            warn=.true.
          endif
c        segment satisfies conditions
          dbound(1)=si*dph
          dbound(2)=(1.d0/si-2.d0*si)*dph
          bound(1)=bound(1)+dbound(1)
          bound(2)=bound(2)+dbound(2)
C         print *,'segment',km,kp,' dph/(2*pi)=',dph/TWOPI
C         print *,'dbound, bound =',
C    *      dbound(1),dbound(2),bound(1),bound(2)
c........vertex terms
          do 240 l=1,2
c        end point is intersection of i circle with k circle
            if (l.eq.1) then
              k=km
            elseif (l.eq.2) then
              if (samebd.ne.0) goto 240
              k=kp
            endif
            cmk=abs(cm(k))
            sk=sqrt(cmk*(2.d0-cmk))
c        cmik = 1-cos th(ik)
            cmik=((rp(1,i)-rp(1,k))**2+(rp(2,i)-rp(2,k))**2
     *        +(rp(3,i)-rp(3,k))**2)/2.d0
c        cpsi = (cik-ci*ck)/(si*sk)
            cpsi=(cmi+cmk-cmi*cmk-cmik)/(si*sk)
            if ((cm(i).ge.0.d0.and.cm(k).lt.0.d0)
     *        .or.(cm(i).lt.0.d0.and.cm(k).ge.0.d0)) cpsi=-cpsi
c        |cpsi| can exceed 1 with nearly kissing circles
            if (cpsi.lt.-1.d0) then
              cpsi=-1.d0
            elseif (cpsi.gt.1.d0) then
              cpsi=1.d0
            endif
            spsi=sqrt(1.d0-cpsi**2)
c        normal boundary
            if (samebd.eq.0) then
c        psi = exterior angle (pi-interior angle) at intersection point
              psi=acos(cpsi)
              if (k.gt.npc) then
                dvert(1)=1.d0+(PI/2.d0-psi)*cpsi/spsi
                vert(1)=vert(1)+dvert(1)
              elseif (k.le.npc) then
                dvert(1)=PI/2.d0*cpsi/spsi
                if ((i.le.npb.and.k.le.npb)
     *            .or.(i.gt.npb.and.k.gt.npb)) then
                  vert(1)=vert(1)-dvert(1)
                elseif ((i.le.npb.and.k.gt.npb)
     *            .or.(i.gt.npb.and.k.le.npb)) then
                  vert(1)=vert(1)+dvert(1)
                endif
              endif
C             print *,l,' samebd =',samebd,' dvert(1), vert(1) =',
C    *          dvert(1),vert(1)
              cti=(1.d0-cmi)/si
              if (cm(i).lt.0.d0) cti=-cti
              ctk=(1.d0-cmk)/sk
              if (cm(k).lt.0.d0) ctk=-ctk
              dvert(2)=spsi/(1.d0+cpsi)**2*(2.d0+cpsi)*(ctk+cti)/2.d0
              vert(2)=vert(2)+dvert(2)
C             print *,l,' samebd =',samebd,
C    *          ' dvert(2), vert(2) part 1 =',
C    *          dvert(2),vert(2)
              dvert(2)=spsi/(1.d0-cpsi)**2*(2.d0-cpsi)*(ctk-cti)/2.d0
              vert(2)=vert(2)+dvert(2)
C             print *,l,' samebd =',samebd,
C    *          ' dvert(2), vert(2) part 2 =',
C    *          dvert(2),vert(2)
c        W2 & W3 share common boundary
            elseif (samebd.ne.0) then
c        W2 & W3 on same side of common boundary
              if (samebd.eq.1) then
c        common boundary is lower limit of segment
                if (mod(iord(j),2).eq.1) then
                  if ((i.le.npb.and.k.gt.npb)
     *              .or.(i.gt.npb.and.k.le.npb)) cpsi=-cpsi
c        common boundary is upper limit of segment
                elseif (mod(iord(j),2).eq.0) then
                  if ((i.le.npb.and.k.le.npb)
     *              .or.(i.gt.npb.and.k.gt.npb)) cpsi=-cpsi
                endif
c        W2 & W3 on opposite sides of common boundary
              elseif (samebd.eq.-1) then
                if ((i.le.npb.and.k.le.npb)
     *            .or.(i.gt.npb.and.k.gt.npb)) cpsi=-cpsi
              endif
              psi=acos(cpsi)
              dvert(1)=1.d0-psi*cpsi/spsi
              vert(1)=vert(1)+samebd*dvert(1)
C             print *,l,' samebd =',samebd,' dvert(1), vert(1) =',
C    *          dvert(1),vert(1)
            endif
  240     continue
  260   continue
      endif
c--------finish off
c        check angle is between 0 and 2*pi
      p=bound(1)/si/TWOPI
c     print *,rp(1,i),rp(2,i),rp(3,i),'angle/(2*pi)=',p
      if (p.lt.0.d0) then
        print *,'*** from gphbv: angle/(2*pi)=',p,
     *    '  should be .ge. 0'
        warn=.true.
      elseif (p.gt.1.d0) then
        if (bound(1)/si.le.TWOPI+areatol) then
          continue
        else
          print *,'*** from gphbv: angle/(2*pi)=',p,
     *      '  should be .le. 1'
          warn=.true.
        endif
      endif
      if (warn) then
        print *,'boundary',i
        write (*,'(a3,a20,4a25)')
     *    ' ','x','y','z',
c    *    'r',
     *    '1-c'
        do j=1,np
          write (*,'(i3,5g25.17)')
     *      j,(rp(i,j),i=1,3),
c    *      sqrt(rp(1,j)**2+rp(2,j)**2+rp(3,j)**2),
     *      cm(j)
        enddo
      endif
 410  continue
      return
      end
c
